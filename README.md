# Rust 实现Gof经典设计模式

设计模式（Design Pattern）是一套被反复使用、多数人知晓、经过分类的、代码设计经验的总结。

### 使用目的：

为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。

### 起源 

与很多软件工程技术一样，模式起源于建筑领域，软件工程只有短短的几十年，与已经拥有几千年底蕴的建筑工程相比，后者有太多值得学习和借鉴的地方。

哈佛大学的建筑学博士克里斯托弗.亚历山大，是建筑学领域的模式之父。他与其研究团队用了约20年的时间，对住宅和周边环境进行了大量的调查研究，发现人们对舒适住宅和城市环境存在一些共同的认同规律，将它们归纳成253个模式。对每一个模式都从前提条件、目标问题、 解决方案三个方面进行了描述，并给出了从需求分析到结构设计再到经典实例的过程模型。

所以，对模式的定义可以抽象为在特定环境下，人们为了解决某类重复出现问题，而总结归纳出来的有效解决方案。

### 诞生 

GoF将模式的概念引入软件工程领域，这标志着软件模式的诞生。软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等，实际上，在软件开发生命周期的每一个阶段都存在着一些被认同的模式。

软件模式主要由四部分构成，包括待解决问题、约束条件、解决方案、优点。

软件模式与具体的应用领域无关，也就是说无论从事的是移动开发、桌面开发、Web开发还是嵌入式软件的开发，都可以使用软件模式。

在软件模式中，设计模式是研究最为深入的分支，它融合了众多专家的设计经验，已经在成千上万的软件中得以应用。 1995年， GoF将收集和整理好的23种设计模式汇编成了一本名叫《设计模式》的书，该书的出版也标志着设计模式正式成为面向对象版软件工程的一个重要研究分支。

## 总体来说设计模式分为三大类：

- 创建模式：用来构建对象以便能从实现系统解耦。
- 结构模式：用不同的对象组成大规模的对象结构。
- 行为模式：用来在对象中管理算法，关系，和责任。

### 创建型模式

- 工厂模式（Factory Pattern）
- 抽象工厂模式（Abstract Factory Pattern）
- 单例模式（Singleton Pattern）
- 建造者模式（Builder Pattern）
- 原型模式（Prototype Pattern）

### 结构型模式

- 适配器模式（Adapter Pattern）
- 桥接模式（Bridge Pattern）
- 过滤器模式（Filter、Criteria Pattern）
- 组合模式（Composite Pattern）
- 装饰器模式（Decorator Pattern）
- 外观模式（Facade Pattern）
- 享元模式（Flyweight Pattern）
- 代理模式（Proxy Pattern）

### 行为型模式

- 责任链模式（Chain of Responsibility Pattern）
- 命令模式（Command Pattern）
- 解释器模式（Interpreter Pattern）
- 迭代器模式（Iterator Pattern）
- 中介者模式（Mediator Pattern）
- 备忘录模式（Memento Pattern）
- 观察者模式（Observer Pattern）
- 状态模式（State Pattern）
- 空对象模式（Null Object Pattern）
- 策略模式（Strategy Pattern）
- 模板模式（Template Pattern）
- 访问者模式（Visitor Pattern）

### 另外的两种模式：

- 并发模式
   - future
- 线程池模式

## 设计模式六大原则

总原则：开闭原则（Open Close Principle）

开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。想要达到这样的效果，我们需要使用接口和抽象类等。

1. 单一职责原则 （SRP：Single responsibility principle）

不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。

2. 里氏替换原则（Liskov Substitution Principle） 

里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。

3. 依赖倒转原则（Dependence Inversion Principle） 

这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。

4. 接口隔离原则（Interface Segregation Principle） 

这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。

5. 迪米特法则（最少知道原则）（Demeter Principle） 
就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。

最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。

6. 合成复用原则（Composite Reuse Principle） 
原则是尽量首先使用合成/聚合的方式，而不是使用继承。

